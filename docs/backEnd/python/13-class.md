# 类与对象
## 类(class)和实例
### 类
整数、字符串、浮点数等，不同的数据类型就属于不同的类。  
想想看当初学数据类型，我们用type验证数据类型后打印的结果

忘了就再来看看：
```py
strs = '字符串'
ints = 1
floats = 2.3

print(type(strs)) # <class 'str'>
print(type(ints)) # <class 'int'>
print(type(floats)) # <class 'float'>
```
以上，class就是类。

顾名思义class 'str'就表示是字符串类。  
同理，剩下俩个就是整数类、浮点数类...

> 类之所以为类，是因为每一个类之下都包含无数相似的不同个例。  
类，是对某个群体的统称。
比如：人类、犬类

### 实例
> 在Python的术语里，我们把类的个例就叫做实例 (instance)，可理解为“实际的例子”。  

比如上边代码中的'字符串'、1、2.3。这三个就分别是字符串类的实例、整数类的实例、浮点数类的实例。

> 类是某个群体，实例是群体中某个具体的个体。  
群体里的每个个体都有着相同/相似的特征和行为。也就是说实例之间会有相同/相似的特征和行为。

比如，字符串中的实例举几个例子：
```py
str1 = '我是字符串'
str2 = '1'
str3 = '2.3'
str4 = 'True'
```
以上四个都是字符串，因为他们都是用英文引号包裹。这就是他们的相同特征。

即使他们四个的内容值完全不一样。

而也因此，值不一样就是他们实例之间的区别、是区别于其他实例个体的特征。
### 小测试
请问：狗、秋田犬、忠犬八公、list、[1,2]  
以上这五个元素，哪个是类、哪个是实例？
```md
答案见源码同目录下files中同名py文件
```

## 对象(object)
> 佛说：万事万物，皆可为对象。

咳咳，佛说，我说的不是男女对象那个对象！
> 这里所谓Python中的对象，等于类和实例的集合：类可以看作是对象，实例也可以看作是对象。

比如列表list是个类对象，[1,2]是个实例对象，它们都是对象。

再比如说人类是个类对象，也可以说小红是个实例对象（这里小红依旧不是你的女对象！！！清醒点！！蚂蚁竞走了十年了！！！）。
## 属性和方法
区别于其他类的依据，细分可以分成两种：
1. 第一种是描述事物是怎样的，有什么特征 - 这就是所说的【属性】
2. 第二种是描述事物能做什么，有哪些行为和作用 - 也就是所说的【方法】


Python中每个类都有自己独特的属性(attribute)和方法(method)，是这个类的所有实例都共享的。换言之，每个实例都可以调用类中所有的属性和方法。  
不过各个类的属性和方法，是需要我们自行创建的。除了python中已有的数据类型其属性和方法是内置建好的。
<!-- 列表的内置属性有中括号包裹、元素用逗号隔开。而 -->
比如：列表的内置方法有append、pop等。而这些方法任何列表实例值都可以使用
```py
listObject = [1,3,'列表实例里的第三个元素']  # 一个列表实例
listObject.append('我是列表实例利用类上的append方法添加进来的元素') # 调用列表类的内置方法append
print(listObject) # [1, 3, '列表实例里的第三个元素', '我是列表实例利用类上的append方法添加进来的元素']
```

## 类的创建
上节，函数用`def`关键字定义。

本节，类的创建用`class`关键字定义。

### 伪代码
```py
class 首字母大写的类变量名:
  自定义属性名 = 属性值
  def 自定义方法名(self,参数1,可以没有参数2):
    方法函数体内容
```
具体的含义:
1. 用`class`关键字创建，class+类名+英文冒号
2. 类名首字母大写，是自定义命名，大写字母开头，不能和python关键字冲突。
3. 类的代码体要放在缩进里。
4. 属性名自定义，不能和python关键字冲突。属性值直接用等号赋值给自定义属性名即可
5. 实例方法名自定义，不能和python关键字冲突。方法（也就是函数）通过`def`关键字定义，和函数的定义语句很类似，
6. 实例方法的第一个参数必须传`self`，固定值。（下详）
7. 类中创建的属性和方法可以被其所有的实例调用
8. 实例的数目在理论上是无限的。我们可以同时“新建”多个实例【类被称为“实例工厂”的由来】

### 示例代码
```py
# 创建一个男朋友类对象
class MyBoyfriend:
  sex = 'male'
  def caring(self):
    print('好了，不哭了~')
  
boyfriend = MyBoyfriend() # 调用类对象，得到男朋友实例对象。
print(type(MyBoyfriend)) # <class 'type'>
print(boyfriend) # <__main__.MyBoyfriend object at 0x109922400> MyBoyfriend类的是一个实例对象。后面的一串字符(0x109922400)表示这个对象的内存地址。
print(type(boyfriend)) # <class '__main__.MyBoyfriend'> 表示boyfriend类属于MyBoyfriend类。
```
### 属性(attribute)
在类中赋值的变量叫做这个类的“属性”

### 方法(method)
在类中定义的函数叫做这个类的“方法”。

类中带`self`的参数的方法是实例方法，是类方法的一种形式，也是最常用的一种方法。
## 类的实例化
还是以上边创建男朋友类的代码为例，类的实例化过程就是`MyBoyfriend()`这句。
最后创建的实例对象被赋值给变量`boyfriend`。

调用类对象的过程叫作**类的实例化**，即用某个类创建一个实例对象。

实现形式/伪代码是
```py
实例变量名 = 类名() # 类名后+小括号调用
```

## 实例对象调用类属性和方法
实例化类对象后，得到一个实例对象。因为类的方法和属性，实例对象都有。所以实例对象`boyfriend`可以调用类中的属性`sex`和方法`caring`。
### 调用类的属性
```py
实例名.属性
```
### 调用类的方法
```py
实例名.方法(传参) # 参数不用考虑self
```
### 示例代码
```py
# 调用类的属性
print(boyfriend.sex) # 打印"male"

# 调用类的方法
boyfriend.caring() # 打印“好了，不哭了~”
```
值得说明的是，调用类方法时，传参不用考虑self参数的存在。
## 创建类的两个关键点
可以看到上例，为什么实例调用方法时不用传参，在定义时那个参数self又是什么意思呢？
### 特殊参数：self
> 这个参数self的特殊之处：“在定义时不能丢，在调用时要忽略。”

### 初始化方法